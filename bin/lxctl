#!/bin/bash

### Simple LXC controller Usage:help
#
# This is a simple wrapper script to better facilitate using lxc. It supports providing the container name alone (rather than
# having to insert -n when you forgot it), and implicitly filling in the container in simple situations; and automatically using
# sudo unless explicitly switched off.
#
#
#	[ SUDOCMD=[sudo] ] lxctl { create | destroy | start | stop } [ { CONTAINER | "." } [ OPTIONS ] ]
#
#	[ SUDOCMD=[sudo] ] lxctl ls OPTIONS
#
#	lxctl last [ CONTAINER ]
#
#
# Calls the appropriate LXC action on the specified container. If CONTAINER is not specified, lxctl will attempt to use the last
# explicitly specified container.
#
# You can call `lxctl last` to see the container, or provide a container name to set the container.
#
# You can use "." as the name of a container to specifically use the last-used container.
#
# You can type a partial container name too for example if you have two containers "myapp" and "myapp-live",
# you can type
#
#   lx info live
#
# to automatically select the live app. If you use the name "app", it will match neither, and attempt to give you info on
# a container exactly named "app". This works for all commands except "create" and "destroy".
#
#
# The list of actions in the first example are a subset - the real subset is in fact any command in the lxc-* family.
#
# Environment variables:
#
#	SUDOCMD - if you explicitly set this to an empty string, the actions will not use sudo
#
#	BACKINGSTORE - defines the backing store used to store data; one of
#		dir - the default, uses simply a directory
#			can take the additional option
#			--dir ROOTFSPATH : the path to the rootfs of the container
#
#		best - tries in order btrfs, zfs, lvm, then dir.
#
#		btrfs - use a btrfs system backed by the host filesystem's btrfs layer
#
#		zfs - use a zfs system backed by the host filesystem's zfs layer
#
#		lvm - use a LVM system backed by a LVM block device
#			takes additional options
#			--lvname LVNAME : the name of the logical volume to create
#			--vgname VGNAME : the name of the volume group to use or create
#			--thinpool THINPOOLNAME : the name of the thinpool to use or create
#
#		loop - use a file representing the filesystem, mounted on the loopback device
#
#		lvm and loop
#			both take additional options
#			--fstype FSTYPE : the filesystem to use (default is "ext4")
#			--fssize FSSIZE : the size of the volume (default is "1G")
#
#		(see `man lxc-create` or `lxctl create --help` option for more information)
#
# 	DOWNLOAD_KEYSERVER
#	 	To work around a bug when behind stringent firewalls, any "create -t download" operation is called using a keyserver on port 80
#	 	This is always active. You can override which key server is used by setting DOWNLOAD_KEYSERVER in your environment
#	 	DOWNLOAD_KEYSERVER must be the HKP URL to a keyserver, or remain undefined to use the default.
#
# DEFAULTS FILE
#
# You can configure default arguments for commands in $HOME/.config/lxctl/defaults
#
# The line strucutre for the defaults file is
#
# 	command ARUGUMENTS
#
# The arguments is a sequence of tokens to be passed, with "{}" denoting where the command line arguments passed at runtime should be inserted.
#
# For example
#
# 	create -t download {} -- -t ubuntu -a amd64
#
# This causes any create command passed without any arguments to by default select the download template, and specify the distro and architecture.
#
###/doc

set -euo pipefail

LXCONFIGDIR="$HOME/.config/lxctl"
LASTCONTAINERF="$LXCONFIGDIR/last"
LXDEFAULTSFILE="$LXCONFIGDIR/defaults"

if [[ ! -d "$LXCONFIGDIR" ]]; then
	mkdir -p "$LXCONFIGDIR"
fi

touch "$LXDEFAULTSFILE"

function printhelp {
	echo -e "\033[1;35m"
	sed "$(egrep -n '^.+Usage:' "$0"|cut -d':' -f1|head -n 1),$(grep -n '###/doc' "$0"|cut -d':' -f1|head -n 1) p" -n "$0"
	echo -e "\033[0m"
	exit
}

if [[ -z "$*" ]] || [[ "$*" = "--help" ]]; then
	printhelp
fi

function faile {
	echo -e "\033[31m$*\033[0m" >&2
	exit
}

function getcontainer {
	local clist="$($SUDOCMD lxc-ls |sed -r 's/\s+/\n/g'| grep "$1")"
	if [[ "$(echo "$clist"|wc -l|cut -d' ' -f1)" != 1 ]]; then
		echo "[33m$clist[0m" >&2
		# Must have only one result, else return the input itself
		echo "$1"
	else
		echo "$clist"
	fi
}

function readdeffile {
	local defline="$(grep -P "^$1\s" "$LXDEFAULTSFILE"|tail -n 1)"
	echo "${defline/$1/}" | tee /dev/stderr
}

function getpreargs {
	echo "$1"|sed -r 's/\{\}.*$//'
}

function getpostargs {
	if [[ "$1" =~ \{\} ]]; then
		echo "$1"|sed -r 's/^.*\{\}//'
	fi
}

function getlastcontainer {
	if [[ -f "$LASTCONTAINERF" ]]; then
		cat "$LASTCONTAINERF"
	fi
}

function setlastcontainer {
	echo "$1" > "$LASTCONTAINERF"
}

ACTION="$1"; shift

if [[ "$*" =~ --help ]]; then
	man "lxc-$ACTION"
	exit
fi

# Elevation prefix
: ${SUDOCMD=sudo}

: ${ROOTHOME=}
if [[ -n "$SUDOCMD" ]]; then
	: ${ROOTHOME=/root}
fi

# Backingstore option
: ${BACKINGSTORE=dir}
BACKINGSTORE="-B $BACKINGSTORE"

## Internal general options
# Added options we may want to insert before the extra options
PREOPTS=
# Set the indicator that says hey there are extended options
XTRATOKEN=
# Placeholder for extended options
EXTRAOPTS=

## User-defined general options
DEFAULTS="$(readdeffile "$ACTION")"
PREARGS="$(getpreargs "$DEFAULTS")"
POSTARGS="$(getpostargs "$DEFAULTS")"
: ${DOWNLOAD_KEYSERVER="hkp://p80.pool.sks-keyservers.net:80"}

# Process actions that do  not take containers
case "$ACTION" in
	last)
		if [[ -z "$*" ]]; then
			getlastcontainer
		else
			setlastcontainer "$1"
		fi
		exit
		;;
	create)
		PREOPTS="$PREOPTS $BACKINGSTORE"
		if [[ "$*" =~ "-t download" ]]; then
			EXTRAOPTS="$EXTRAOPTS --keyserver $DOWNLOAD_KEYSERVER"
		fi
		;;
esac

if ! which "lxc-$ACTION" 2>/dev/null >/dev/null ; then
	faile "No such action lxc-$ACTION"
fi

# Add our own token if one does not already exist in the user's args
if [[ -n "$EXTRAOPTS" ]] && [[ ! "$*" =~ $(echo ' -- ') ]]; then
	XTRATOKEN='--'
fi

if [[ -n "$*" ]]; then
	CONTAINER="$1"; shift
	if [[ "$ACTION" != create ]] && [[ "$ACTION" != destroy ]]; then
		CONTAINER="$(getcontainer "$CONTAINER")"
	fi
fi

if [[ -z "${CONTAINER:-}" ]] || [[ "${CONTAINER:-}" = '.' ]]; then
	CONTAINER="$(getlastcontainer)"
fi

(
	# Print out a copy of the call, for info
	set -x

	# Do not quote token and opts -- would be safer to be able to turn them into array ...
	"$SUDOCMD" HOME="$ROOTHOME" "lxc-$ACTION" -n "$CONTAINER" $PREOPTS $PREARGS "$@" $POSTARGS $XTRATOKEN $EXTRAOPTS
)
RES=$?

if [[ "$RES" = 0 ]]; then
	echo "$CONTAINER" > "$LASTCONTAINERF"
fi

